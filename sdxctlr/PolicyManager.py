# Copyright 2016 - Sean Donovan
# AtlanticWave/SDX Project


import cPickle as pickle

from threading import Timer, Lock, Thread
from datetime import datetime, timedelta

from lib.AtlanticWaveManager import AtlanticWaveManager
from AuthorizationInspector import AuthorizationInspector
from BreakdownEngine import BreakdownEngine
from ValidityInspector import ValidityInspector
from TopologyManager import TopologyManager

from shared.constants import *

# Define different states!
ACTIVE_POLICY               = 1
INACTIVE_POLICY             = 2
EXPIRED_POLICY              = 3
INSUFFICIENT_PRIVILEGES     = 4

def STATE_TO_STRING(state):
    if state == 1:
        return "ACTIVE POLICY"
    elif state == 2:
        return "INACTIVE POLICY"
    elif state == 3:
        return "EXPIRED POLICY"
    elif state == 4:
        return "INSUFFICIENT PRIVILEGES"




class PolicyManagerError(Exception):
    ''' Parent class, can be used as a catch-all for other errors '''
    pass

class PolicyManagerTypeError(TypeError):
    ''' if there's a type error. '''
    pass

class PolicyManagerValidationError(PolicyManagerError):
    ''' When a validation fails, raise this. '''
    pass

class PolicyManagerBreakdownError(PolicyManagerError):
    ''' When a breakdown fails, raise this. '''
    pass

class PolicyManagerAuthorizationError(PolicyManagerError):
    ''' When a authorization fails, raise this. '''
    pass

def TESTING_CALL(param):
    ''' PolicyManager requires two parameters for proper initialization. However
        we also want for the REST API to be able to get a copy of the 
        PolicyManger easily.'''
    raise PolicyManagerError("PolicyManager has not been properly initialized")

class PolicyManager(AtlanticWaveManager):
    ''' The PolicyManager keeps track of all policies that are installed (and 
        their metadata), the breakdowns of the abstract policy per local 
        controller as created by the BreakdownEngine, as well as orchestrating 
        new policy requests and removals.
        Workflow: The REST API will send new policies by participants who are 
        allowed to send policies (of any type), it will be sent to the 
        ValididyInspector to check if it is a valid policy, then sent to the 
        BreakdownEngine to break it into constituent parts, and finally the 
        PolicyManager will check with the AuthorizationInspector to see if the 
        breakdowns are allowed to be installed by that particular user. 
        Singleton. ''' 
    
    
    def __init__(self, db_filename, loggeridprefix='sdxcontroller',
                 send_user_policy_breakdown_add=TESTING_CALL,
                 send_user_policy_breakdown_remove=TESTING_CALL):
        # The params are used in order to maintain import hierarchy.
        loggerid = loggeridprefix + ".policymanager"
        super(PolicyManager, self).__init__(loggerid)
        
        # Setup timers and their associated locks.
        # Timer code in part based on https://github.com/sdonovan1985/py-timer
        self.install_timer = None
        self.install_next_time = None
        self.install_lock = Lock()
        self.remove_timer = None
        self.remove_next_time = None
        self.remove_lock = Lock()

        # Start database
        db_tuples = [('policy_table','policies'), ('config_table', 'config')]
        self._initialize_db(db_filename, db_tuples)

        # Policy Table cleanup
        try:
            # Need to cleanup autogenerated policies. These cannot be used after
            # reboot, as they may be outdated: we cannot tell, so we must delete
            self.policy_table.delete(user=AUTOGENERATED_USERNAME)
        except:
            # No big deal, there may not have been any.
            pass

        print "Policies present at initialization:"
        for policy in self.policy_table:
            print "   - %s" % policy
        # Used for filtering of policy_table
        self._valid_table_columns = ['hash', 'policytype', 'user',
                                     'state', 'starttime', 'stoptime']


        # Config table setup
        # Initialize policy counter. Used to track the policies as they are
        # installed. It may be in the DB.
        policynum = self.config_table.find_one(key='policy_number')
        if policynum == None:
            self.policy_number = 1
            self.config_table.insert({'key':'policy_number',
                                      'value':self.policy_number})
        else:
            self.policy_number = policynum['value']

        print "Policy number = %d" % self.policy_number

        last_modified = self.config_table.find_one(key='last_modified')
        if last_modified == None:
            now = datetime.now()
            last_modified = now.strftime(rfc3339format)
            self.config_table.insert({'key':'last_modified',
                                      'value':last_modified})

        # Use these to send the policy to the Local Controller
        self.set_send_add_rule(send_user_policy_breakdown_add)
        self.set_send_rm_rule(send_user_policy_breakdown_remove)

        # Setup callback lists:
        self.install_callbacks = []
        self.remove_callbacks = []

        self.logger.warning("%s initialized: %s" % (self.__class__.__name__,
                                                    hex(id(self))))
        
    def set_send_add_rule(self, fcn):
        self.send_user_add_rule = fcn

    def set_send_rm_rule(self, fcn):
        self.send_user_rm_rule = fcn

    def add_policy(self, policy):
        ''' Adds a policy for a particular user. Returns policy hash if 
            successful, failure message based on why the policy installation 
            failed. Also returns a reference to the policy (e.g., a tracking 
            number) so that more details can be retrieved in the future. '''

        self.logger.info("add_policy: Beginning with policy: %s" % policy)
        self._update_last_modified_timestamp()
        try:
            breakdown = self._determine_breakdown(policy)
        except Exception: raise
        self.dlogger.info("add_policy: breakdowns %s" % breakdown)        

        # If everything passes, set the hash, cookie, and breakdown,
        # put into database and call install_callbacks
        policyhash = self._get_new_policy_number()
        policy.set_policy_hash(policyhash)
        for entry in breakdown:
            entry.set_cookie(policyhash)
        policy.set_breakdown(breakdown)
        self.dlogger.info("add_policy: hash and cookies set to %s" % policyhash)

        policy.pre_add_callback(TopologyManager(), AuthorizationInspector())
        self._add_policy_to_db(policy)

        self._call_install_callbacks(policy)
        self.dlogger.info("add_policy: Policy added to db: %s" % policy)

        return policyhash
        

    def test_add_policy(self, policy):
        ''' Similar to add policy, save for actually pushing the policy to the 
            local controllers. Useful for testing out whether a policy will be
            added as expected, or to preview what policies will be pushed to the
            local controller(s). '''
        try:
            breakdown = self._determine_breakdown(policy)
        except Exception as e: raise

        return breakdown

    def remove_policy(self, policy_hash, user):
        ''' Removes the policy that corresponds to the policy_hash that was 
            returned either from add_policy() or found with get_policies(). If 
            user does not have removal ability, returns an error. '''

        self.logger.info("remove_policy: Beginning with policy: %s" %
                         policy_hash)
        if self.policy_table.find_one(hash=policy_hash) == None:
            raise PolicyManagerError("policy_hash doesn't exist: %s" %
                                     policy_hash)

        self._update_last_modified_timestamp()
        policy = pickle.loads(str(
            self.policy_table.find_one(hash=policy_hash)['policy']))
        authorized = None
        try:
            authorized = AuthorizationInspector().is_authorized(user, policy) #FIXME
        except Exception as e:
            raise PolicyManagerAuthorizationError(
                "User %s is not authorized to remove policy %s with exception %s" %
                (user, policy_hash, str(e)))
        if authorized != True:
            raise PolicyManagerAuthorizationError(
                "User %s is not authorized to remove policy %s" %
                (user, policy_hash))
        self.dlogger.info("remove_policy: Starting removal of policy: %s" %
                          policy_hash)
        
        policy.pre_remove_callback(TopologyManager(),
                                   AuthorizationInspector())
        self._rm_policy_from_db(policy)
        self._call_remove_callbacks(policy)
        self.dlogger.info("remove_policy: Policy removed from db: %s" %
                          policy_hash)

    def remove_all_policies(self, user):
        ''' Removes all policies. Just an alias for repeatedly calling 
            remove_policy() without needing to know all the hashes. '''
        for policy in self.policy_table.find():
            parsed_policy = pickle.loads(str(policy['policy']))
            # Skip autogenerated policies
            if parsed_policy.get_user() == AUTOGENERATED_USERNAME:
                continue
            self.remove_policy(policy['hash'], user)

    def get_policy_search_fields(self):
        ''' This returns fields that can be used in get_policies()'s filter.
            Basically, this is any of the columns used in the 
            policy_table.insert() action. There is some variation (the policy is
            pickled, so not useful), but it tracks most of the colunmns. '''

        #FIXME: make this more general, so that it can actually search for
        #something like "starts between 8 and 10am". Further, should be able to
        #tell users what values are valid for particular fields. The
        #PolicyRegistry should help out here.

        return self._valid_table_columns

    def get_policies(self, filter={}, ordering=None):
        ''' Used for searching for policies based on a filter. The filter could 
            be based on the policy type, the user that installed the policy, the
            local controllers that have policies installed, or the hash_value of
            the policy. This will be useful for both administrators and for 
            participants for debugging. This will return a list of tuples 
            (policy_hash, json version of policy, policytype, user, state as 
            string). 

            filter is a dictionary with any of the fields that belong to what is
            returned by get_policies_search_fields(). Optional.

            orderring is the field to order the results by. For reversing, 
            adding a - to the front is valid. E.g., "hash" will return in 
            ascending order, while "-hash" will return in decending. 
            Optional.'''
        #FIXME: make this more general, so that it can actually search for
        #something like "starts between 8 and 10am".
        
        # Validate that the filter is valid.
        if filter != None:
            if type(filter) != dict:
                raise PolicyManagerTypeError("filter is not a dictionary: %s" % 
                                           type(filter))
            for key in filter.keys():
                if key not in self._valid_table_columns:
                    raise PolicyManagerValidationError(
                        "filter column '%s' is not a valid filtering field %s" %
                        (key, self._valid_table_columns))

        # Handle ordering, if necessary.
        if ordering != None:
            filter['order_by'] = ordering
        
        # Do the search on the table
        results = self.policy_table.find(**filter)


        #FIXME: need to figure out what to send back to the caller of the
        #policies. What does the policy look like? Should it be the JSON
        #version? I think so.
        retval = [(x['hash'],
                   pickle.loads(str(x['policy'])).get_json_policy(),
                   x['policytype'],
                   pickle.loads(str(x['policy'])).get_user(),
                   STATE_TO_STRING(str(x['state']))) for x in results]
        return retval

    def get_breakdown_rules_by_LC(self, lc):
        ''' This gets broken down rules for a particular LC. Used at 
            connection startup by the SDXController. 
            Returns a list of broken down policies. 
        '''
        bd_list = []
        # Get all policies
        all_policies = self.policy_table.find()
        # For each policy, look at each breakdown
        for table_entry in all_policies:
            policy = pickle.loads(str(table_entry['policy']))
            for bd in policy.get_breakdown():
                # If Breakdown is for this LC, add to bd_list
                policy_lc = bd.get_lc()
                if policy_lc == lc:
                    bd_list += bd.get_list_of_rules()
        return bd_list
    
    def get_policy_details(self, policy_hash):
        ''' This will return details of a policy, including the policy itself, 
            the local controller breakdowns, and the user who installed the 
            policy. 
            Returns tuple (policy_hash, json version of policy, policytype, 
            state, user, list of text versions of breakdowns) '''
        table_entry = self.policy_table.find_one(hash=policy_hash)
        if table_entry != None:
            policy = pickle.loads(str(table_entry['policy']))
            
            # get the pieces
            jsonpolicy = policy.get_json_policy()
            policytype = policy.get_policytype()
            state = STATE_TO_STRING(table_entry['state'])
            user = policy.get_user()

            breakdowns = []
            for bd in policy.get_breakdown():
                lc = bd.get_lc()
                breakdowns += ["%s:%s" % (lc, str(x)) for x in 
                               bd.get_list_of_rules()]
            
            # Return as a tuple
            return (policy_hash, jsonpolicy, policytype, state, user,
                    breakdowns)

        return None

    def get_raw_policy(self, policy_hash):
        ''' This will return the actual policy, for advanced manipulation. '''
        table_entry = self.policy_table.find_one(hash=policy_hash)
        if table_entry != None:
            policy = pickle.loads(str(table_entry['policy']))
            return policy
        return None

    def register_for_policy_updates(self, install_callback, remove_callback):
        ''' Callback will be called when there is a policy update (install or 
            delete. 
            install_callback will be called when there's a new policy installed.
            remove_callback will be called when a policy is removed.
            Both callbacks can be the same function.
        '''
        if install_callback != None:
            self.install_callbacks.append(install_callback)
        if remove_callback != None:
            self.remove_callbacks.append(remove_callback)

    def unregister_for_topology_updates(self, install_callback=None,
                                        remove_callback=None):
        ''' Remove callback from list of callbacks to be called. '''
        if install_callback != None:
            try:
                self.install_callbacks.remove(install_callback)
            except:
                raise PolicyManagerError(
                    "Trying to remove %s, not in install_callbacks: %s" %
                    (install_callback, self.install_callbacks))
        if remove_callback != None:
            try:
                self.remove_callbacks.remove(remove_callback)
            except:
                raise PolicyManagerError(
                    "Trying to remove %s, not in remove_callbacks: %s" %
                    (remove_callback, self.remove_callbacks))

    def _call_install_callbacks(self, policy):
        ''' Call all install_callbacks. '''
        for cb in self.install_callbacks:
            cb(policy)

    def _call_remove_callbacks(self, policy):
        ''' Call all remove_callbacks. '''
        for cb in self.remove_callbacks:
            cb(policy)

    def _get_new_policy_number(self):
        ''' Returns a new policy number for use. For now, it's incrementing by 
            one, but this can be a security risk, so should be a random 
            number/hash.
            Good for 4B (or more!) policies!
        '''
        self.policy_number += 1
        self.config_table.update({'key':'policy_number', 
                                  'value':self.policy_number},
                                 ['key'])
        return self.policy_number

    def _determine_breakdown(self, policy):
        ''' This performs the bulk of the add_policy() and test_add_policy() 
            processing, including all the authorization checking. 
            Raises error if there are any problems.
            Returns breakdown of the policy if successful. '''

        valid = None
        breakdown = None
        authorized = None
        # Check if valid policy
        try:
            valid = ValidityInspector().is_valid_policy(policy)
        except Exception as e:
            self.dlogger.error("Caught Error for policy %s" % policy)
            self.exception_tb(e)
            raise
        
        if valid != True:
            raise PolicyManagerValidationError(
                "Policy cannot be validated: %s" % policy)
        
        # Get the breakdown of the policy
        breakdown = BreakdownEngine().get_breakdown(policy)
        try:
            breakdown = BreakdownEngine().get_breakdown(policy)
        except Exception as e:
            self.dlogger.error("Caught Error for policy %s" % policy)
            self.exception_tb(e)
            raise

        if breakdown == None:
            raise PolicyManagerBreakdownError(
                "Policy was not broken down: %s" % policy)

        # Check if the user is authorized to perform those actions.
        try:
            authorized = AuthorizationInspector().is_authorized(
                policy.username, policy)
        except Exception as e:
            self.dlogger.error("Caught Error for policy %s" % policy)
            self.exception_tb(e)
            raise
            
        if authorized != True:
            raise PolicyManagerAuthorizationError(
                "Policy is not authorized: %s" % policy)

        return breakdown

    def _update_last_modified_timestamp(self):
        ''' Used for setting the last_modified timestamp. '''
        now = datetime.now()
        last_modified = now.strftime(rfc3339format)
        self.config_table.update({'key':'last_modified',
                                  'value':last_modified},
                                 ['key'])

    def get_last_modified_timestamp(self):
        ''' Get the last_modified timestamp. '''
        last_modified_dict = self.config_table.find_one(key='last_modified')
        last_modified = last_modified_dict['value']
        return last_modified

    def _add_policy_to_db(self, policy):
        ''' Adds policy to the database, which also include handling timed 
            insertion of policies. '''
        self.dlogger.info("_add_policy_to_db: %s:%s" % (policy,
                                                policy.get_policy_hash()))
        state = INACTIVE_POLICY

        # Should this be installed now? e.g., Is the begin time before *now*?
        # Set state based on this question.
        # Many policies do *not* have timers associated. If so, set the 
        # install_time to now and remove_time to None. Need to handle these
        # cases below.
        now = datetime.now()
        install_time = now
        remove_time = None
        if policy.get_start_time() != None:
            install_time = datetime.strptime(policy.get_start_time(), 
                                             rfc3339format)
        if policy.get_stop_time() != None:
            remove_time  = datetime.strptime(policy.get_stop_time(), 
                                             rfc3339format)

#        print "Now     : %s" % now
#        print "Install : %s" % install_time
#        print "Remove  : %s" % remove_time

        if remove_time != None and now >= remove_time:
            self.dlogger.info("  EXPIRED_POLICY")
            state = EXPIRED_POLICY
        elif now >= install_time: # implicitly, before remove_time
            state = ACTIVE_POLICY
            self.dlogger.info("  ACTIVE_POLICY")
            self._install_policy(policy)

        # Push into DB.
        # If there are any changes here, update self._valid_table_columns.
        self.policy_table.insert({'hash':policy.get_policy_hash(), 
                                  'policy':pickle.dumps(policy),
                                  'policytype':policy.get_policytype(),
                                  'user':policy.get_user(),
                                  'state':state,
                                  'starttime':policy.get_start_time(),
                                  'stoptime':policy.get_stop_time(),
                                  'extendedbd':pickle.dumps(None)})

        # Restart install timer if it's a policy starting the future
        if state == INACTIVE_POLICY:
            self.dlogger.info("  INACTIVE_POLICY")
            self._restart_install_timer()


    def _rm_policy_from_db(self, policy):
        ''' Removes policy from the database, which also includes cancelling any
            outstanding timed installations of the policy. '''

        # Find policy in DB, get important information: state, start/stop time
        self.dlogger.info("_rm_policy_from_db: %s:%s" % (policy,
                                                policy.get_policy_hash()))
        record = self.policy_table.find_one(hash=policy.get_policy_hash())
        state = record['state']
        starttime = record['starttime']
        stoptime = record['stoptime']

        if state == ACTIVE_POLICY:
            self.dlogger.info(
                "_rm_policy_from_db: removing active policy   %s:%s" %
                (policy, policy.get_policy_hash()))
            self._remove_policy(policy)
            self.policy_table.delete(hash=policy.get_policy_hash())

            if stoptime == self.remove_next_time:
                self._restart_remove_timer()
                
        # If inactive, 
        # Was it the next install timer to pop? If so, update timer.
        elif state == INACTIVE_POLICY:
            self.dlogger.info(
                "_rm_policy_from_db: removing inactive policy %s:%s" %
                (policy, policy.get_policy_hash()))
            self.policy_table.delete(hash=policy.get_policy_hash())
            self._restart_install_timer()

        # If Expired:
        # Nothing specific to do right now
        elif state == EXPIRED_POLICY:
            self.dlogger.info(
                "_rm_policy_from_db: removing expired policy  %s:%s" %
                (policy, policy.get_policy_hash()))
            self.policy_table.delete(hash=policy.get_policy_hash())
            pass
            #FIXME: Recurrent policies are weird. 

        # If Insufficient Privileges:
        # Nothing specific to do right now
        elif state == INSUFFICIENT_PRIVILEGES:
            pass

        self.dlogger.info("_rm_policy_from_db: removed policy %s:%s" %
                          (policy, policy.get_policy_hash()))
            

    def _install_policy(self, policy):
        ''' Helper function that installs a policy into the switch. '''
        try:
            self.dlogger.debug("_install_policy: %s:%d" % (policy,
                                                    policy.get_policy_hash()))
            self._reserve_resources(policy.get_resources())
            self._install_breakdown(policy.get_breakdown())
        except Exception as e: raise
        self._restart_remove_timer()

    def _reserve_resources(self, resource_list):
        ''' Helper function that reserves resources that a policy needs. '''
        for resource in resource_list:
            self.logger.debug("_reserve_resources: %s" % resource)
            TopologyManager().reserve_resource(resource)
        
    def _unreserve_resources(self, resource_list):
        ''' Helper function that unreserves resources that a policy needs. '''
        for resource in resource_list:
            self.logger.debug("_unreserve_resources: %s" % resource)
            TopologyManager().unreserve_resource(resource)

    def _install_breakdown(self, breakdown):
        try:
            for bd in breakdown:
                self.logger.debug("Sending breakdown: %s" % bd)
                for rule in bd.get_list_of_rules():
                    self.logger.debug("    %s" % str(rule))
                self.send_user_add_rule(bd)
        except Exception as e: raise

    def _remove_policy(self, policy):
        ''' Helper function that remove a policy from the switch. '''
        try:
            table_entry = self.policy_table.find_one(
                hash=policy.get_policy_hash())
            extendedbd = pickle.loads(str(table_entry['extendedbd']))
            for bd in policy.get_breakdown():
                self.send_user_rm_rule(bd)
            if extendedbd != None:
                for bd in extendedbd:
                    self.send_user_rm_rule(bd)
            self._unreserve_resources(policy.get_resources())
        except Exception as e: raise
        
    def _policy_install_timer_cb(self):
        ''' This is the timer callback for policy installation. Called when the 
            policy install timer pops. '''

        # Get list of future policies ordered by install time
        policies = self.policy_table.find(state = INACTIVE_POLICY,
                                          order_by = "starttime")

        now = datetime.now()
        next_install_time = None

        # Does first policy in the list need installing? At least one should.
        for policy in policies:
            install_time = datetime.strptime(policy['starttime'],
                                             rfc3339format)
            # If this policy should be installed later, we're done with the loop
            # thanks to policies being in order by start time. First, save off time
            # for the next policy to be installed.
            if now < install_time:
                next_install_time = policy['starttime']
                break

            # Install policy and update state.
            self.policy_table.update({'hash':policy['hash'],
                                      'state':ACTIVE_POLICY}, 
                                     ['hash'])
            
            self._install_policy(pickle.loads(str(policy['policy'])))
            
        
        # Set timer for next policy install, if necessary.
        self._restart_install_timer()            

    def _policy_remove_timer_cb(self):
        ''' This is the timer callback for policy removal (expiring policies). 
            Called when the policy removal timer pops. '''

        # Get the list of existing policies, ordered by expiry time.
        policies = self.policy_table.find(state = ACTIVE_POLICY,
                                          order_by = "stoptime")

        now = datetime.now()
        next_remove_time = None

        # Is the first policy in the list also expired? At least one should be.
        for policy in policies:
            remove_time = datetime.strptime(policy['stoptime'],
                                            rfc3339format)
            
            # If this policy should be removed later, we're done with the loop
            # thanks to policies being in order by stop time. First, save off
            # time for the next policy to be installed.
            if now < remove_time:
                next_remove_time = policy['stoptime']
                break

            # Remove policy and update state.
            self.policy_table.update({'hash':policy['hash'],
                                      'state':EXPIRED_POLICY}, 
                                     ['hash'])
            self._remove_policy(policy)
            #FIXME: Recurrant policies will need to be updated on the install
            #list potentially.

        # Set timer for next policy removal, if necessary
        self._restart_remove_timer()

    def _restart_remove_timer(self):
        ''' Internal function for starting the remove timer. ''' 
        # Is the policy active? If so, remove it from the LCs.
        # Was it the next remove timer to pop? If so, need to update timer.
        with self.remove_lock:
            # Clean up existing remove timer
            if self.remove_timer != None:
                self.remove_timer.cancel()
            self.remove_timer = None
            self.remove_next_time = None

            # Pull next active policies, and reset the timer.
            active_policies = self.policy_table.find(state=ACTIVE_POLICY,
                                                     order_by="stoptime")
            #, _limit=1)

            # If there are no new active policies, this was just be skipped
            for r in active_policies:
                # If it's a policy that lasts forever, skip it
                if r['stoptime'] == None:
                    continue
                # We only want the first one (the soonest to stop), so
                # there's a break at the end of this loop.
                now = datetime.now()
                self.remove_next_time = r['stoptime']
                delta = (datetime.strptime(self.remove_next_time,
                                           rfc3339format) - now)
                self.remove_timer = Timer(delta.total_seconds(),
                                          self._policy_remove_timer_cb)
                self.remove_timer.daemon = True
                self.remove_timer.start()
                break

    def _restart_install_timer(self):
        with self.install_lock:
            # Clean up existing install timer
            if self.install_timer != None:
                self.install_timer.cancel()
            self.install_timer = None
            self.install_next_time = None

            # Pull next inactive policy, and reset the timer.
            inactive_policies = self.policy_table.find(state=INACTIVE_POLICY,
                                                       order_by="starttime", 
                                                       _limit=1)

            # If there are no new active policies, this was just be skipped
            for r in inactive_policies:
                now = datetime.now()
                self.install_next_time = r['starttime']
                delta = (datetime.strptime(self.install_next_time,
                                           rfc3339format) - now)
                self.install_timer = Timer(delta.total_seconds(),
                                           self._policy_install_timer_cb)
                self.install_timer.daemon = True
                self.install_timer.start()
                
    def change_callback_dispatch(self, cookie, data):
        ''' This is used to handle changes callbacks. It performs four main 
            functions:
              - Find the policy that this change callback belongs to
              - Call the change callback with data, possibly receive breakdown
                to install.
              - if received breakdown, install it
              - if received breakdown, update database of installed additional 
                breakdown.
        '''
        table_entry = self.policy_table.find_one(hash=cookie)
        if table_entry == None:
            raise PolicyManagerError("policy_hash doesn't exist: %s" %
                                     policy_hash)

        policy = pickle.loads(str(table_entry['policy']))

        breakdown = policy.switch_change_callback(TopologyManager(),
                                                  AuthorizationInspector(),
                                                  data)
        if breakdown == None:
            return

        self.logger.debug("_change_callback_dispath")
        self._install_breakdown(breakdown)

        extendedbd = pickle.loads(str(table_entry['extendedbd']))
        if extendedbd == None:
            extendedbd = breakdown
        else:
            for entry in breakdown:
                extendedbd.append(entry)

        self.policy_table.update({'hash':table_entry['hash'],
                                  'extendedbd':pickle.dumps(extendedbd)},
                                 ['hash'])

